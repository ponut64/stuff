
#ifndef __DEF_H__
# define __DEF_H__

//def.h -- the catch-all "i dunno where else this goes" files
#define true	(1)
#define false	(0)
//////////////////////////////////
// Uniform grid cell information / shorthands
//////////////////////////////////
#define CELL_SIZE (2621440) // 40 << 16
#define INV_CELL_SIZE (1638) // 40 / 1
#define CELL_SIZE_INT (40)
#define MAP_V_SCALE (17) //Map data is shifted left by this amount
//////////////////////////////////
#define	HIMEM	(100679680)
#define HWRAM_MODEL_DATA_HEAP_SIZE (256 * 1024)
//////////////////////////////////
#define UNCACHE (0x20000000)
#define VDP2_RAMBASE (0x25E00000)
#define LWRAM (0x200000)
#define LWRAM_END (LWRAM + 0x100000)
//////////////////////////////////
// Polygon draw direction flipping flags
//////////////////////////////////
#define FLIPV (32)
#define FLIPH (16)
#define FLIPHV (48)
//////////////////////////////////
// Fixed point safe-square value
//////////////////////////////////
#define SQUARE_MAX (9633792) //147<<16
//////////////////////////////////
//	The line width of the polygon map area, in vertices (pix) and polygons (ply).
//	The total size is the square of these values.
//	These, in combination with the cell size, also control the render distance.
//	I should improve the render distance. I could do this with the Tribes-inspired "morph map" idea:
//	The inner area of the visible region is "true to final size". In this case it would be 15 pixels (forward from player).
//	Outside of that is a region in which each vertex is skipping two pixels of the heightmap, and so is "quarter-res".
//	I guess it would be 6 pixels forward from player.
//	In reality, this would be generated by the DSP scanning two tables for the system:
//	One true-to-size table, at least (LCL_MAP_PIX<<1) in size.
//	Another quarter-to-size table, at least (LCL_MAP_PIX<<1) in size that consists of data which reads by:
//	Reading every fourth pixel on every fourth line of the main map.
//	Between these two tables, there is another table, the "local map mesh circle table".
//	This is a table which basically overlays the two tables generated by the DSP into a single table where:
//	The center is the "true to size" map, and the outskirts are the "quarter-res" map.
//	Generally the idea there is the true-to-size map is 15 pixels from the center.
//	Then, one or the other CPU (possibly the DSP also) will generate a "render list".
//	Basically, we are mapping vertices / pixels of the heightmap to an area that is effectively four times the size of the view area.
//	We want to render an area that is 21x21 vertices, but hashed out a 42x42 vertex table, for example.
//	The render list table builds the 21x21 view area from the 42x42 table.
//	Then we render that table.
//
//	How is this more complicated than current table:
//	Current steps are:
//	1 - Master CPU finds player cell location and height map configuration, sends to DSP
//	2 - DSP picks up configuration, and spits out a table of heightmap pixel # to use for the local map
//	3 - Master CPU picks up table, writes the data at pixel # in table to linearly mapped vertex # (as table is LCL_MAP_PIX * LCL_MAP_PIX)
//	4 - Master CPU draws local map
//	Repeat
//	New steps would (potentially) be:
//	1 - (Same)
//	2 - DSP spits out two tables: true to size table, and quarter-res table, based on player location. Ditches division function.
//	3 - DSP also spits out render list table, telling master CPU which portions of those tables to use. These compare well logically.
//	4 - Master CPU picks up tables, uses pre-computed 'circle table' to use near-table or far-table in combination with list table.
//	5 - Master CPU writes data at pixel # to tabled vertex #
//	6 - Master CPU draws local map
//
//	Two concerns:
//	1. Is the DSP fast enough to do this? Almost certainly, never know.
//	2. Bus contention: Can the DSP write all that data back (~18KB) without tripping up the processors?
//	3. How much will Master CPU be tripped up by the extra level of indirection about pasting vertices?
//
//////////////////////////////////
#define LCL_MAP_PIX (21)
#define LCL_MAP_PLY (20)
//////////////////////////////////
//	Numerical Normal ID Shorthands
//////////////////////////////////
#define N_Xp (0)
#define N_Xn (1)
#define N_Yp (2)
#define N_Yn (3)
#define N_Zp (4)
#define N_Zn (5)

#define GRAVITY (6553)
///////////////////////////////////
// Game logic timing data
///////////////////////////////////
extern int delta_time;
//////////////////////////////////////////////////////////////////////////////
//Sound Numbers
//////////////////////////////////////////////////////////////////////////////
extern int snd_dash;
extern int snd_lstep;
extern int snd_wind;
extern int snd_bstep;
extern int snd_click;
extern int snd_button;
extern int snd_cronch;
extern int snd_alarm;
extern int snd_win;
extern int snd_freturn;
extern int snd_ftake;
extern int snd_bwee;
extern int snd_smack;
extern int snd_khit;
extern int snd_clack;
extern int snd_close;
extern int snd_button2;
extern int snd_ffield1;
extern int snd_ffield2;
extern int snd_ring1;
extern int snd_ring2;
extern int snd_ring3;
extern int snd_ring4;
extern int snd_ring5;
extern int snd_ring6;
extern int snd_ring7;
extern Sint8 * stmsnd[64];
extern int stm_win;
extern int stm_freturn;
extern int stm_orchit0;
//////////////////////////////////////////////////////////////////////////////
extern int flagIconTexno;

//Structs
typedef struct {
	FIXED pos[XYZ];
	FIXED wpos[XYZ];
	int startPos[XYZ];
	int cellPos[XY];
	int dispPos[XY];
	int prevCellPos[XY];
	int prevDispPos[XY];
	FIXED prevPos[XYZ];
	int id;
	int rot[XYZ]; //It needs to be an INT... NO IDEA WHY...
	int rot2[XYZ];
	int renderRot[XYZ];
	ANGLE viewRot[XYZ];
	int rotState[XYZ];
	FIXED velocity[XYZ];
	FIXED gravAccel;
	FIXED Accel[XYZ];
	FIXED Force[XYZ];
	FIXED ControlUV[XYZ];
	FIXED DirUV[XYZ];
	FIXED SurfUV[XYZ];
	FIXED IPaccel;
	
	FIXED moment[XYZ];
	FIXED mass;
	Bool dirInp;
	Bool setJump;
	Bool setSlide;
	Bool okayStepSnd;
	Bool climbing;
	Bool ladder;
	Bool wasClimbing;
	Bool inMenu;
	int sanics;
	
	short power;
	short maxPower;
	Bool setJet;
	
	int surfaceHeight;
	POINT	shadowPos;
	POINT	floorPos;
	POINT	wallPos;
	POINT	viewpoint;
	VECTOR	floorNorm;
	VECTOR	wallNorm;
	FIXED surfFriction;
	
	int points;
	
	Bool aboveObject;
	Bool hitMap;
	Bool hitObject;
	Bool hitBox;
	Bool hitSurface;
	Bool hitWall;
} _player;

//////////////////////////////////////////////////////////////////////////////
// Player data struct
//////////////////////////////////////////////////////////////////////////////
extern _player you;

//Variables
extern POINT zPt;
extern POINT alwaysLow;
//Lives in main.c
extern short * division_table;
//extern short * sine_table;
extern void * HWRAM_ldptr;
//System
extern unsigned char * dirty_buf;
extern void * currentAddress;
extern int framerate;
extern int frmul;
extern volatile Uint32 * scuireg;

#endif

